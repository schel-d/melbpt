import { DateTime } from "luxon";
import { getElementOrThrow } from "../dom-utils";
import { fetchDepartures } from "../stop/departure-request";
import { determineDepartureGroups } from "../stop/departure-group";
import { DepartureModel } from "../stop/departure-model";
import { DepartureGroupController } from "../stop/departure-group-controller";
import { initTimeControls } from "../stop/time-controls";

declare global { interface Window { stopID: number } }

/**
 * The last minute {@link update} ran in.
 */
let lastUpdate: DateTime | null = null;

/**
 * Runs when the script is initialized.
 */
function init() {
  // The stop page has an extra script (generated by the pug template) that
  // attaches the stopID onto the window object.
  const stopID = window.stopID;

  // Decide which groups to make for this page, and create controllers for each.
  // Each group should initially show a loading spinner in it's UI.
  const groups = determineDepartureGroups(stopID);
  const controllers = groups.map(g => new DepartureGroupController(g));
  controllers.forEach(c => c.showLoading());

  // Append each departure group's div to the page.
  const departuresDiv = getElementOrThrow("departures");
  departuresDiv.append(...controllers.map(c => c.groupDiv));

  // Retrieve the departures, update the odometers, etc.
  const now = DateTime.utc().startOf("minute");
  lastUpdate = now;
  update(stopID, controllers, now);

  // Every second, check if a new minute has started, and if so, run update()
  // again.
  setInterval(() => {
    const now = DateTime.utc().startOf("minute");
    if (lastUpdate == null || !lastUpdate.equals(now)) {
      lastUpdate = now;
      update(stopID, controllers, now);
    }
  }, 1000);

  setupDropdowns();
}

/**
 * Runs at the start of each minute. Responsible for updating the departure UIs
 * (pinging the api for updates, counting down the live time odometers, etc.).
 * @param stopID The stop ID.
 * @param controllers The departure group controllers created in {@link init}.
 * @param now The minute in time that this update is occuring for.
 */
async function update(stopID: number, controllers: DepartureGroupController[],
  now: DateTime) {

  // Get each group to update it's departures' live times odometers.
  controllers.forEach(c => c.updateLiveTimes(now));

  try {
    // Formulate request to api, and await it's response.
    const count = Math.max(...controllers.map(c => c.group.count));
    const filters = controllers.map(c => c.group.filter + " narr nsdo");
    const response = await fetchDepartures(stopID, now, count, false, filters);

    // Using the up-to-date network data, find this stop.
    const stop = response.network.stops.find(s => s.id == stopID);
    if (stop == null) { throw new Error(`Couldn't find this stop in the network.`); }

    controllers.forEach((c, i) => {
      // Generate the departure models (objects that store just what is
      // displayed) for this group from the api response, and pass them to the
      // controller so it can update the UI.
      const departures = response.departures[i];
      const models = departures.map(d =>
        new DepartureModel(d, stop, response.network)
      );
      c.showDepartures(models);
    });
  }
  catch {
    controllers.forEach(c => c.showError());
  }
}

function setupDropdowns() {
  const openClass = "open";
  const timeButton = getElementOrThrow("time-controls-button");
  const filterButton = getElementOrThrow("filter-controls-button");
  const timeDropdown = getElementOrThrow("time-controls-dropdown");
  const filterDropdown = getElementOrThrow("filter-controls-dropdown");
  const timeOpen = () => timeDropdown.classList.contains(openClass);
  const filterOpen = () => filterDropdown.classList.contains(openClass);

  // Open the dropdown if its corresponding button is clicked.
  timeButton.addEventListener("click", () => {
    timeDropdown.classList.toggle(openClass);
    filterDropdown.classList.remove(openClass);
  });
  filterButton.addEventListener("click", () => {
    filterDropdown.classList.toggle(openClass);
    timeDropdown.classList.remove(openClass);
  });

  // Allows a click outside either dropdown or an escape key to close them.
  document.addEventListener("click", (e) => {
    const clickedElement = e.target as HTMLElement;
    if (timeOpen() && !timeDropdown.contains(clickedElement) &&
      !timeButton.contains(clickedElement)) {
      timeDropdown.classList.remove(openClass);
      e.preventDefault();
    }
    if (filterOpen() && !filterDropdown.contains(clickedElement) &&
      !filterButton.contains(clickedElement)) {
      filterDropdown.classList.remove(openClass);
      e.preventDefault();
    }
  });
  document.addEventListener("keydown", (e) => {
    if (e.code == "Escape" && (filterOpen() || timeOpen())) {
      timeDropdown.classList.remove(openClass);
      filterDropdown.classList.remove(openClass);
      e.preventDefault();
    }
  });

  initTimeControls();
}

// Run init. Placed at end of file so
init();
